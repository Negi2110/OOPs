
// =====================================================
// TOPIC: delete Operator in C++ (Interview Perspective)
// =====================================================
//
// What is `delete`?
// -----------------------------------------------------
// `delete` is used to FREE memory that was dynamically
// allocated on the HEAP using the `new` operator.
//
// Heap memory is NOT automatically freed like stack
// memory ‚Äî the programmer is responsible.
//
// -----------------------------------------------------
// Why delete is required?
// -----------------------------------------------------
//
// - Stack variables are destroyed automatically
// - Heap variables live until explicitly deleted
// - Not deleting heap memory causes MEMORY LEAK
//
// -----------------------------------------------------
// Basic Syntax
// -----------------------------------------------------
//
// delete pointer;
//
// Example:
MyClass* myObject = new MyClass();
// use myObject
delete myObject;    // frees heap memory
//
// -----------------------------------------------------
// What happens internally when delete is called?
// -----------------------------------------------------
//
// 1. Destructor of the object is called
// 2. Memory is returned to the heap (free store)
// 3. Pointer becomes DANGLING (still holds old address)
//
// -----------------------------------------------------
// VERY IMPORTANT: Dangling Pointer Issue
// -----------------------------------------------------
//
// After delete, pointer still stores the address
// but the memory is INVALID.
//
// BAD:
delete myObject;
myObject->func();   // ‚ùå undefined behavior
//
// GOOD PRACTICE:
delete myObject;
myObject = nullptr;
//
// -----------------------------------------------------
// delete vs delete[]
// -----------------------------------------------------
//
// delete:
// - Used for SINGLE object allocated with `new`
//
// delete[]:
// - Used for ARRAYS allocated with `new[]`
//
// Example:
int* a = new int[5];
delete[] a;         // correct
//
// WRONG:
delete a;           // ‚ùå undefined behavior
//
// -----------------------------------------------------
// What can be passed to delete?
// -----------------------------------------------------
//
// ‚úî Pointer returned by `new`
// ‚úî Pointer set to nullptr
//
// ‚ùå Stack memory pointer
// ‚ùå Memory not allocated by new
//
// Example:
int x = 10;
int* p = &x;
delete p;           // ‚ùå ERROR
//
// -----------------------------------------------------
// delete nullptr is SAFE
// -----------------------------------------------------
//
// int* p = nullptr;
// delete p;          // safe, does nothing
//
// -----------------------------------------------------
// Common Interview Pitfalls
// -----------------------------------------------------
//
// ‚ùå Forgetting delete ‚Üí memory leak
// ‚ùå Using delete instead of delete[]
// ‚ùå Double delete
// ‚ùå Accessing pointer after delete
//
// -----------------------------------------------------
// One-Line Interview Answer
// -----------------------------------------------------
//
// "`delete` frees dynamically allocated heap memory
// and calls the object's destructor."
```

Only memory allocated using new lives on the HEAP.
All pointer variables themselves live where they are declared (usually the STACK).
‚ÄúPointers always live where they are declared (usually stack); only the memory obtained via new lives on the heap, regardless of how many * are used.‚Äù
## ‚≠ê Quick Interview Q&A

**Q: Does delete set pointer to NULL?**
‚û° ‚ùå No (you must do it manually)

**Q: Is delete mandatory in modern C++?**
‚û° ‚ùå Prefer **smart pointers** (`unique_ptr`, `shared_ptr`)

**Q: What happens if delete is not called?**
‚û° Memory leak

---

## üß† Modern C++ Interview Bonus

```cpp
#include <memory>

std::unique_ptr<MyClass> obj = std::make_unique<MyClass>();
// No delete needed (RAII)




## üîë Core Rule (repeat once more)

> **Only memory allocated using `new` lives on the HEAP.**
> **Pointer variables live where they are declared (usually STACK).**

This rule applies **100% to linked lists**.

---

## 1Ô∏è‚É£ Typical Linked List Node

```cpp
struct Node {
    int data;
    Node* next;
};
```

This struct **does not decide stack or heap** by itself.

---

## 2Ô∏è‚É£ Creating a Linked List Node (MOST COMMON)

```cpp
Node* head = new Node{10, nullptr};
```

### Memory layout

```text
STACK:
head  --------> 0x5000

HEAP:
0x5000:
   data = 10
   next = nullptr
```

### Important points (INTERVIEW GOLD)

```cpp
// head        -> lives on STACK
// *head       -> Node object on HEAP
// head->data  -> on HEAP
// head->next  -> on HEAP
```

‚úî The **entire node (data + next pointer)** lives on the **heap**
‚úî The pointer `head` itself lives on the **stack**

---

## 3Ô∏è‚É£ Adding Another Node

```cpp
head->next = new Node{20, nullptr};
```

### Memory layout

```text
STACK:
head  --------> 0x5000

HEAP:
0x5000:
   data = 10
   next = 0x6000

0x6000:
   data = 20
   next = nullptr
```

### Key clarification

```cpp
// Node 1 (data + next) -> HEAP
// Node 2 (data + next) -> HEAP
// head pointer         -> STACK
```

üëâ **All linked list nodes are on the HEAP**
üëâ **Only the pointers you use to access them are on the STACK**

---

## 4Ô∏è‚É£ Traversing the List

```cpp
Node* curr = head;
```

```cpp
// curr -> STACK
// curr points to HEAP nodes
```

If you move `curr`:

```cpp
curr = curr->next;
```

```cpp
// curr changes value
// HEAP nodes stay exactly where they are
```

---

## 5Ô∏è‚É£ Linked List Inside a Function

```cpp
void createList() {
    Node* head = new Node{1, nullptr};
}
```

```cpp
// head is destroyed when function ends (stack)
// Node on heap STILL EXISTS ‚Üí MEMORY LEAK
```

‚úî This is why linked lists **must be deleted manually**

---

## 6Ô∏è‚É£ Deleting a Linked List (VERY IMPORTANT)

```cpp
Node* curr = head;
while (curr) {
    Node* temp = curr;
    curr = curr->next;
    delete temp;
}
```

```cpp
// delete frees HEAP nodes
// stack pointers disappear automatically
```

---

## 7Ô∏è‚É£ Common Interview Traps ‚ùå

### ‚ùå Wrong

> ‚ÄúLinked list nodes are on stack‚Äù

### ‚úÖ Correct

> **Linked list nodes are on heap; pointers to them are on stack**

---

## 8Ô∏è‚É£ Stack vs Heap in Linked List (Table)

| Item                         | Stored where |
| ---------------------------- | ------------ |
| `head` pointer               | Stack        |
| `curr` pointer               | Stack        |
| `Node` object                | Heap         |
| `data` inside node           | Heap         |
| `next` pointer (inside node) | Heap         |

---

## ‚≠ê One-Line Interview Answer

> **‚ÄúIn a linked list, nodes are allocated on the heap, while the pointer variables used to access them live on the stack.‚Äù**
