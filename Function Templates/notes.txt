
## âœ… What Is a Function Template? (Simple Meaning)

> A **function template** allows you to write **one generic function** that works for **many data types** instead of writing the same function again and again.

So instead of writing:

```cpp
int add(int, int);
float add(float, float);
double add(double, double);
```

You write **one template** and the compiler generates the correct versions automatically âœ…

---

## âœ… Why Function Templates Are Used

From your slide:

* âœ… Work with **generic types**
* âœ… **Avoid code duplication**
* âœ… Implemented using **template parameters**
* âœ… Types are passed as **arguments to the function**

---

## âœ… Syntax (From Your Slide)

Both are **100% equivalent**:

```cpp
template <class T>
```

or

```cpp
template <typename T>
```

Used as:

```cpp
template <typename T>
T functionName(T a, T b);
```

âš  `class` and `typename` mean the **same thing here**.

---

## âœ… Fully Commented Function Template Example

```cpp
#include <iostream>
using namespace std;

/*
====================================================
FUNCTION TEMPLATE
====================================================
- T is a GENERIC TYPE
- Same function works for:
  âœ… int
  âœ… float
  âœ… double
  âœ… any type that supports +
*/

template <typename T>
T Add(T a, T b) {
    return a + b;
}

int main() {

    // âœ… Compiler generates Add<int>(int, int)
    cout << Add(10, 20) << endl;           // Output: 30

    // âœ… Compiler generates Add<float>(float, float)
    cout << Add(2.5f, 1.5f) << endl;       // Output: 4.0

    // âœ… Compiler generates Add<double>(double, double)
    cout << Add(3.14, 2.86) << endl;       // Output: 6.0

    return 0;
}
```

---

## âœ… What Actually Happens Internally (Important Interview Point)

* The compiler **does NOT generate real code immediately**
* It **waits until you use the template**
* Then it **creates a real function for each type**

Example:

```cpp
Add<int>(10, 20);
Add<float>(2.5f, 1.5f);
```

These become **separate real functions at compile time**.

This is called:

> âœ… **Compile-time polymorphism**

---

## âœ… Template vs Function Overloading

| Feature                     | Function Overloading | Function Template |
| --------------------------- | -------------------- | ----------------- |
| Code reuse                  | âŒ No                 | âœ… Yes             |
| Generic                     | âŒ No                 | âœ… Yes             |
| Compile-time                | âœ… Yes                | âœ… Yes             |
| Number of functions written | Many                 | One               |

---

## ğŸ”¥ One-Line Interview Finisher

> â€œA function template allows writing a single generic function that the compiler automatically instantiates for different data types at compile time, avoiding code duplication.â€

---


> Yes â€” when you use a **function template**, you do **not need to overload the same function for `int`, `float`, `double`, etc.** The **compiler automatically generates the correct version** based on the type you pass.

---

## âœ… Without Template (Overloading Needed)

```cpp
int Add(int a, int b) {
    return a + b;
}

float Add(float a, float b) {
    return a + b;
}
```

âœ… More code
âœ… Repetition
âŒ Hard to maintain

---

## âœ… With Template (One Function Handles All)

```cpp
template <typename T>
T Add(T a, T b) {
    return a + b;
}
```

Now:

```cpp
Add(10, 20);        // int version auto generated
Add(2.5f, 1.5f);   // float version auto generated
Add(3.0, 4.0);     // double version auto generated
```

âœ… One function
âœ… Works for all numeric types
âœ… Cleaner code
âœ… Compile-time efficient

---

## âœ… Final One-Line Interview Answer

> â€œFunction templates remove the need for writing multiple overloaded functions for different data types by letting the compiler automatically generate the correct version at compile time.â€

