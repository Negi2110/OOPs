
#include <iostream>
using namespace std;

class GameObject {
private:
    int id;

public:
    // Parameterized constructor
    // Because we define this, the compiler normally STOPS generating a default constructor.
    GameObject(int inID) : id(inID) {
        cout << "Parameterized constructor called: id = " << id << endl;
    }

    // C++11 default specifier (= default)
    // This tells the compiler:
    // "Even though I have non-default constructors,
    // STILL generate a default constructor for me."
    GameObject() = default;   // âœ” Forces compiler to create a default constructor

    // Copy constructor (generated by compiler if not defined)
    GameObject(const GameObject&) = default;

    // Copy assignment operator
    GameObject& operator=(const GameObject&) = default;

    // Destructor
    ~GameObject() = default;
};

int main() {
    GameObject obj1;         // âœ” Works because default constructor is forced by = default
    GameObject obj2(10);     // âœ” Uses parameterized constructor

    return 0;
}
// ```

// ---

// # ðŸ“Œ **Crisp Interview Notes (inside comments above)**

// * By default, C++ auto-generates:
//   âœ” default constructor
//   âœ” copy constructor
//   âœ” copy assignment operator
//   âœ” destructor

// * BUT these are **NOT** generated if you define your own constructor.

// * Using `= default` **forces** the compiler to generate them anyway.

// ---

// # âœ” Example Summary (copy-paste for interview)

// * `= default` tells the compiler to **automatically generate** a constructor or operator.
// * Useful when you define your own constructors but still want a compiler-generated default one.
// * Works only in **C++11 and later**.
// * Example:

//   ```cpp
//   MyClass() = default;
//   ```

// ---

// If you want, I can also create the version that fails without `= default` to help you compare.
