// =============================================================
// MUTEX EXPLANATION WITH BATHROOM ANALOGY (INTERVIEW READY)
// =============================================================
//
// Think of a mutex like a BATHROOM ðŸš»
//
// â€¢ The bathroom can be used by ONLY ONE person at a time.
// â€¢ The bathroom represents the CRITICAL SECTION.
// â€¢ The key to the bathroom represents the MUTEX.
//
// -------------------------------------------------------------
// CASE 1: Using lock()
// -------------------------------------------------------------
//
// Code:
//   m.lock();
//
// Bathroom analogy:
// â€¢ You go to the bathroom.
// â€¢ If it is occupied, you WAIT outside.
// â€¢ You do nothing else until it becomes free.
// â€¢ Once free, you enter and lock the door.
//
// Thread behavior:
// â€¢ The thread gets BLOCKED.
// â€¢ The OS pauses the thread.
// â€¢ The thread cannot execute any further code.
// â€¢ It resumes only after the mutex is unlocked.
//
// Interview point:
// â€¢ lock() is a BLOCKING call.
// â€¢ The protected task will run later, not immediately.
//
// -------------------------------------------------------------
// CASE 2: Using try_lock()
// -------------------------------------------------------------
//
// Code:
//   if (m.try_lock()) { /* critical section */ }
//
// Bathroom analogy:
// â€¢ You check the bathroom door ONCE.
// â€¢ If it is free, you enter.
// â€¢ If it is occupied, you WALK AWAY immediately.
// â€¢ You do NOT wait.
// â€¢ You do NOT keep checking automatically.
//
// Thread behavior:
// â€¢ The thread is NOT blocked.
// â€¢ It continues executing other code.
// â€¢ The protected task is skipped or deferred.
//
// Interview point:
// â€¢ try_lock() is a NON-BLOCKING call.
// â€¢ The task may never run, depending on program logic.
//
// -------------------------------------------------------------
// IMPORTANT CLARIFICATION (COMMON INTERVIEW TRAP)
// -------------------------------------------------------------
//
// Incorrect statement:
//   "Other thread will not be able to perform its task."
//
// Correct statement:
// â€¢ Other thread will NOT be able to perform the
//   CRITICAL SECTION task.
// â€¢ The thread ITSELF is NOT stopped.
// â€¢ It may still perform other NON-protected work.
//
// -------------------------------------------------------------
// DOES try_lock() KEEP CHECKING AUTOMATICALLY?
// -------------------------------------------------------------
//
// NO.
//
// try_lock():
// â€¢ Checks mutex availability ONLY ONCE.
// â€¢ Returns immediately.
// â€¢ Does NOT retry.
// â€¢ Does NOT spin.
// â€¢ Does NOT block.
//
// If repeated checking happens, it is because
// the PROGRAMMER wrote a loop (busy waiting).
//
// -------------------------------------------------------------
// SUMMARY COMPARISON
// -------------------------------------------------------------
//
// lock():
// â€¢ Blocks the thread
// â€¢ Waits until mutex is available
// â€¢ OS handles waiting
//
// try_lock():
// â€¢ Never blocks
// â€¢ Checks once and returns
// â€¢ Thread keeps running
//
// -------------------------------------------------------------
// INTERVIEW ONE-LINER
// -------------------------------------------------------------
//
// If a mutex is occupied, other threads cannot execute
// the critical section; with lock() they wait, and with
// try_lock() they move on.
//
// =============================================================
